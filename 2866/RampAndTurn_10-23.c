#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     rightArmMotor, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightMotor,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     leftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftArmMotor,  tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    lockServo,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//le Mark, if you ever use French articles for naming functions/variables again I may explode.

/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*                                   - Drive Off Ramp and Knock Down Pole -                               *|
|*                                            						                                                *|
|*                                                                                                        *|
|*    This program makes the robot drive foward until the robot is entirely off of the ramp               *|
|*		and then use a gyro sensor to turn 90 degrees. Finally, the robot uses the IR Sensor								*|
|*		to determine the position of the center goal and with that information the robot turns							*|
|*		to align itself with the pole and drive into the pole and knock it over.														*|
|*																																																			  *|
|*		Team Members:																																											  *|
|*				Ethan O'Dell						Mark Raymond Jr.								Josh Zahner															*|
|*                                                                                                        *|
|*    NOTES:                                                                                              *|
|*    1)  The Gyro Sensor and the IR Sensor should be somewhere on the FRONT of the		                    *|
|*				robot, facing foward.																																						*|
|*    2)	The time used in this program is based upon the drive train of the 2866 robot.                  *|
|*			  The time was calculated from timing the robot getting to the end of the ramp										*|
|*				and averaged after several trials.																															*|
|*		3)  Position One IR value is 5, Position Two IR value is 7, Position Three is to 								    *|
|*				far away for the IR sensor to find a value				  																						*|
|*    																																														        *|
\*------------------------------------------------------------------------------------------------2866----*/


/*------------------------------------------ Includes ----------------------------------------------------*/

#include "JoystickDriver.c"
#include <hitechnic-gyro.h>

/*------------------------------------------ Variables ---------------------------------------------------*/

float gyroValue;
bool left = true;
bool right = false;

/*------------------------------------------ Gyro Code ---------------------------------------------------*/

task update_Gyro()
{
	HTGYROstartCal(gyroSensor);
	while(true)
	{
		gyroValue += HTGYROreadRot(gyroSensor) / 100.0;
		displayTextLine(3, "%d", gyroValue);
		wait1Msec(10);
	}
}

/*------------------------------------------ IR Code ---------------------------------------------------*/

int getIR() //Simply grabs the value returned from the IR sensor
{
	return SensorValue[irSensor];
}


void debugIR()
{
		writeDebugStreamLine("The IR Value is: %d", getIR());
		wait1Msec(1000);
}

/*---------------------------------------- Drive Code ---------------------------------------------------*/

void moveFowardForTime(int motorspeed, float seconds)
{
	motor[leftMotor] = motorspeed;
	motor[rightMotor] = motorspeed;
	wait1Msec(seconds*1000);
}

void driveWithGyro(int angle, int motorspeed)
{
		gyroValue = 0;
		if (angle < gyroValue)
		{
			motor[rightMotor] = motorspeed + 5;
			motor[leftMotor] = motorspeed;
		}
		else if (angle > gyroValue)
		{
			motor[rightMotor] = motorspeed;
			motor[leftMotor] = motorspeed + 5;
		}
		else
		{
			motor[leftMotor] = motorspeed;
			motor[rightMotor] = motorspeed;
		}
}

void turnWithGyro(int angle, int motorspeed, bool direction)
{

	if(direction == left)
	{
		while(gyroValue > angle)
		{
			motor[leftMotor] = -motorspeed;
			motor[rightMotor] = motorspeed;
		}
	}
	else if(direction == right)
	{
		while(gyroValue < angle)
		{
	 		motor[leftMotor] = motorspeed;
			motor[rightMotor] = -motorspeed;
		}
	}
}


//Finds the position of the Center goal
void getPositionOfIR()
{
	//Position with IR beacon directly in front of the robot
	if(getIR() == 5)
	{
		writeDebugStreamLine("Found First Position at IR %d", getIR());
		turnWithGyro(-23, 75, left);
		driveWithGyro(0, 100);
		wait1Msec(2500);
	}
	else if(getIR() == 6 || getIR() == 7)
	{
		writeDebugStreamLine("Found Second Position at IR %d", getIR());
		turnWithGyro(-23, 75, left);
		//gyroValue = 0;
		driveWithGyro(0, 100);
		wait1Msec(2500);
		turnWithGyro(90, 75, right);
		//gyroValue = 0;
		driveWithGyro(0, 100);
		wait1Msec(2500);
	}
	else
	{
		writeDebugStreamLine("Either Third Position at %d or No IR", getIR());
		driveWithGyro(0, 70);
		wait1Msec(5000);
		turnWithGyro(20, 50, right);
		wait1Msec(1500);
		turnWithGyro(-90, 100, left);
	}
}

/*---------------------------------------- The Main Task ---------------------------------------------------*/

void initializeRobot()
{
	clearDebugStream();
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void getOffRamp()
{
	writeDebugStreamLine("Starting");
	waitForStart();
	driveWithGyro(0, 30);
	wait1Msec(4000);
	writeDebugStreamLine("Off of ramp");
	gyroValue = 0;
	turnWithGyro(-5, 35, left);
	writeDebugStreamLine("Gyro Value: %d", gyroValue);
	writeDebugStreamLine("Turned 90 degrees");
}

void knockDownPole()
{
	gyroValue = 0;
	debugIR();
	getPositionOfIR();
}

task main()
{
	startTask(update_Gyro);
	initializeRobot();
	waitForStart();
	getOffRamp();
	knockDownPole();
}
