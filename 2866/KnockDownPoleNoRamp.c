#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     rightArmMotor, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightMotor,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     leftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftArmMotor,  tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    lockServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//le Mark, if you ever use French articles for naming functions/variables again I may explode.

/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*                                   - Drive Off Ramp and Knock Down Pole -                               *|
|*                                            						          					                            *|
|*                                                                                                        *|
|*    This program makes the robot drive foward until the robot is entirely off of the ramp               *|
|*		and then use a gyro sensor to turn 90 degrees. Finally, the robot uses the IR Sensor							  *|
|*		to determine the position of the center goal and with that information the robot turns						  *|
|*		to align itself with the pole and drive into the pole and knock it over.													  *|
|*																																																			  *|
|*		Team Members:																																											  *|
|*				Ethan O'Dell						Mark Raymond Jr.						Josh Zahner																	*|
|*                                                                                                        *|
|*    NOTES:                                                                                              *|
|*    1)  The Gyro Sensor and the IR Sensor should be somewhere on the FRONT of the		                    *|
|*				robot, facing foward.																																						*|
|*    2)	The time used in this program is based upon the drive train of the 2866 robot.                  *|
|*			  	The time was calculated from timing the robot getting to the end of the ramp									*|
|*				and averaged after several trials.																															*|
|*	  3)  Position One IR value is 5, Position Two IR value is 7, Position Three is to 								    *|
|*				far away for the IR sensor to find a value				  																						*|
|*    																																														        *|
\*------------------------------------------------------------------------------------------------2866----*/


/*------------------------------------------ Includes ----------------------------------------------------*/

#include "JoystickDriver.c"
#include <hitechnic-gyro.h>


/*------------------------------------------ Variables ---------------------------------------------------*/

float gyroValue;
bool left = true;
bool right = false;

/*------------------------------------------ Gyro Code ---------------------------------------------------*/

task update_Gyro()
{
	HTGYROstartCal(gyroSensor);
	wait1Msec(10);
	while(true)
	{
		float angle = HTGYROreadRot(gyroSensor) / 100.0;
		gyroValue += angle;
		writeDebugStreamLine("Gyro Value: %f", gyroValue);
		wait1Msec(10);
	}
}

/*---------------------------------------- Drive Code ---------------------------------------------------*/

void driveWithGyro(int angle, int motorspeed, float time)
{
	gyroValue = 0;
	clearTimer(T1);
	time *= 1000;
	while(time1[T1] < time)
	{
		if (gyroValue < angle)
		{
			motor[rightMotor] = motorspeed;
			motor[leftMotor] = motorspeed + 5;
		}
		else if (gyroValue > angle)
		{
			motor[rightMotor] = motorspeed + 5;
			motor[leftMotor] = motorspeed;
		}
		else
		{
			motor[leftMotor] = motorspeed;
			motor[rightMotor] = motorspeed;
		}
	}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turnWithGyro(float angle, int motorspeed, bool direction)
{
	if(direction == left)
	{
		while(gyroValue > angle)
		{
			motor[leftMotor] = -motorspeed;
			motor[rightMotor] = motorspeed;
		}
	}
	else if(direction == right)
	{
		while(gyroValue < angle)
		{
			motor[leftMotor] = motorspeed;
			motor[rightMotor] = -motorspeed;
		}
	}
}

/*------------------------------------------ IR Code ---------------------------------------------------*/

//Simply grabs the value returned from the IR sensor
int getIR()
{
	return SensorValue[irSensor];
}

//Finds the position of the Center goal
void getPositionOfIR(float time)
{
	if(getIR() == 5)
	{
		//IR Beacon is directly in front of the off ramp starting zone
		writeDebugStreamLine("Found Third Position at IR %d", getIR());
		turnWithGyro(-10.0, 75, left);
		gyroValue = 0;
		driveWithGyro(0, 100, time);
		turnWithGyro(90.0, 75, right);
	}
	else if(getIR() == 3 || getIR() == 4)
	{
		//IR beacon is about 45 degrees from the off ramp starting zone
		writeDebugStreamLine("Found Second Position at IR %d", getIR());
		turnWithGyro(-23.0, 75, left);
		gyroValue = 0;
		driveWithGyro(0, 100, time);
		turnWithGyro(90.0, 75, right);
	}
	else
	{
		//IR beacon is about 90 degrees from the off ramp starting zone
		writeDebugStreamLine("Either First Position at %d or No IR", getIR());
		gyroValue = 0;
		driveWithGyro(0, 100, time);
		turnWithGyro(90.0, 75, right);
	}
}

void debugIR()
{
	writeDebugStreamLine("The IR Value is: %d", getIR());
}

/*---------------------------------------- The Main Task ---------------------------------------------------*/

void initializeRobot()
{
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	startTask(update_Gyro);
	gyroValue = 0;
	clearDebugStream();
}


void knockDownPole()
{
	/*Gets close to the center goal then knocks down
	the pole based on the position of center goal*/
	driveWithGyro(0, 75, 3.5);
	//wait1Msec(2000);
	debugIR();
	//getPositionOfIR(1.0);
	turnWithGyro(25, 30, right);
	driveWithGyro(0, 50, 1.5);

}

task main()
{
	initializeRobot();
	waitForStart();
	knockDownPole();
}
