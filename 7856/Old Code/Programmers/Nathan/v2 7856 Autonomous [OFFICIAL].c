#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyroSensor,     sensorI2CCustom)
#pragma config(Sensor, S3,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S4,     IRSensor2,      sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     MotorR,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     MotorL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     Bucket,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     MidArm,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     BotArm,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     TopArm,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////																					////
////	Green Army Robotics Team 7856 (Tactical Division) 2013-14 Season "Block Party"	////
////	Purpose: To have the robot move on its own for the Autonomous Period			////
////	Contributors: Daniel Herzberg, Aidan O., Warren Li, 							////
////		Mitchell Skaggs, Nathan Skelton, Alex Tariah								////
////	Last Edited: 10/26/2013															////
////																					////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"
#include <hitechnic-gyro.h>
// Joystick drivers

const int forward = 0;
const int backward = 1;
const int up = 0;
const int down = 1;
const int gyro_on_ramp = 0;
int IRValue = 0;
float happy_angle=0;

task update_IRsensor()
{
	IRValue = SensorValue[IRSensor2];
	nxtDisplayTextLine(6,"IRValue: %d",IRValue);
}

task update_gyroSensor()
{
	HTGYROstartCal(gyroSensor);
	float angle = HTGYROreadRot(gyroSensor) / 100.0;
	happy_angle = happy_angle + angle;
	nxtDisplayTextLine(7,"GyroFromStart: %d", happy_angle);
}

void moveCm(int direction, int distance, int power)
{
	bool encoderAcheived = false;
	int motorEncoderTargetL = 0;
	int motorEncoderTargetR = 0;
	motorEncoderTargetL = distance / 0.028;
	motorEncoderTargetR = distance / 0.028;
	nMotorEncoder[MotorL] = 0;
	nMotorEncoder[MotorR] = 0;
	encoderAcheived = false;
	if (direction == forward)
	{
		while(encoderAcheived == false)
		{
			if((nMotorEncoder[MotorL] < motorEncoderTargetL) && (nMotorEncoder[MotorR] < motorEncoderTargetR))
			{
				motor[MotorR] = power;
				motor[MotorL] = power;
			}
			else
			{
				motor[MotorR] = 0;
				motor[MotorL] = 0;
				encoderAcheived = true;
			}
		}
	}
	else if (direction == backward)
	{
		while(encoderAcheived == false)
		{
			if((nMotorEncoder[MotorL] > motorEncoderTargetL) && (nMotorEncoder[MotorR] > motorEncoderTargetR))
			{
				motor[MotorR] = power;
				motor[MotorL] = power;
			}
			else
			{
				motor[MotorR] = 0;
				motor[MotorL] = 0;
				encoderAcheived = true;
			}
		}
	}
}

void rotateright(int powerLevel, int stopAngle)
{
	while (happy_angle != stopAngle)
	{
		motor[MotorL] = - powerLevel;
		motor[MotorR] = powerLevel;
		nxtDisplayTextLine(1,"Rotating Left");
		StartTask(update_gyroSensor);
	}
}

void rotateleft(int powerLevel, int stopAngle)
{
	while (happy_angle != stopAngle)
	{
		motor[MotorL] = powerLevel;
		motor[MotorR] = - powerLevel;
		nxtDisplayTextLine(1,"Rotating Right");
		StartTask(update_gyroSensor);
	}
}


void move(int direction, int motorspeed, int time)
{
	if (direction == backward)
	{
		motor[MotorL] = - motorspeed;
		motor[MotorR] = - motorspeed;
		nxtDisplayTextLine(1,"Moving Backward");
		wait1Msec(time);
	}
	else if (direction == forward)
	{
		motor[MotorL] = motorspeed;
		motor[MotorR] = motorspeed;
		nxtDisplayTextLine(1,"Moving Forward");
		wait1Msec(time);
	}
	else
	{
		nxtDisplayTextLine(1,"Stoping");
		motor[MotorL] = 0;
		motor[MotorR] = 0;
	}
}

void stop_drive()
{
	nxtDisplayTextLine(1,"Stoping");
	motor[MotorL] = 0;
	motor[MotorR] = 0;
}

void drive_on_ramp(int motorspeed)
{
	nxtDisplayTextLine(2,"Finding Ramp");
	while (happy_angle < gyro_on_ramp)
	{
		move(forward, motorspeed, 0);
	}
	nxtDisplayTextLine(2,"Stoping On Ramp");
	stop_drive();
}

void find_ir_basket(int motorspeed, int rotatemotorspeed, int angle)
{
	while (IRValue != 8)
	{
		move(forward, motorspeed, 0);
		StartTask(update_IRsensor);
	}
	if (IRValue == 8)
	{
		rotateleft(rotatemotorspeed, angle);
	}
	else
	{
		stop_drive();
	}
}

void arm(int motorpower, int direction)
{
	if (direction == up)
	{
		motor[TopArm] = motorpower;
		motor[MidArm] = motorpower;
		motor[BotArm] = motorpower;
		wait10Msec(150);
		motor[TopArm] = 0;
		motor[MidArm] = 0;
		motor[BotArm] = 0;
	}
	else if (direction == down)
	{
		motor[TopArm] = -motorpower;
		motor[MidArm] = -motorpower;
		motor[BotArm] = -motorpower;
	}
}

void move_bucket(int direction, int time)
{
	if (direction	== up)
	{
		motor[Bucket] = 100;
		wait10Msec(time);
		motor[Bucket] = 0;
	}
	else if (direction == down)
	{
		motor[Bucket] = 100;
		wait10Msec(time);
		motor[Bucket] = 0;
	}
}

void score_in_basket(int motorspeed, int distance, int buckettime)
{
	arm(motorspeed, up);
	moveCm(forward, distance, motorspeed);
	move_bucket(down, buckettime);
}

task main()
{
	find_ir_basket(25, 30, 90);
	score_in_basket(75, 30, 100);
	moveCm(backward, 32, -75);
}
