#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irSensor1,      sensorI2CCustom)
#pragma config(Sensor, S3,     irSensor2,      sensorI2CCustom)
#pragma config(Sensor, S4,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     motorFL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorFR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorBR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorLift1,    tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    clawL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    clawR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////
// Green Army Robotics Team 2866 (Covert Division) 2012-13 Season "Ring It Up" //
// Purpose: To provide control of the Robot during the Tele-Op period          //
// Contributors: Kyle Hall, Grant Matthews, Warren Li, Tom Sarsfield           //
// Last Edited: 2/22/13																												 //
/////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"

/////////////////////////
// Global Variables:	 //
/////////////////////////

#define level1Value 1500	// Motor encoder value for raising the arm to the lowest row
#define level2Value 3100	// Motor encoder value for raising the arm to the middle row
#define level3Value 6100	// Motor encoder value for raising the arm to the highest row
#define armSpeed 50  			// Speed at which to move the arm

/////////////////////////
// Global Functions:   //
/////////////////////////

int scale_motor (int joyVal)
{
	// This function is used to convert a value from the analogue stick into a value to be used by a motor.
	// It takes in a joystick value between -128 and 127 and scales it to a motor value between -100 and 100

	const int   deadzone = 10; 															// Size of the joystick dead zone
	const float max_joy_range = 127.0; 											// Maximum value of the joystick
	const int   max_motor_range = 100;											// Maximum value of the motor
	const float ratio =  max_motor_range / max_joy_range;		// The ratio for converting the joystick value to a motor value

	if (abs(joyVal) < deadzone)				// If the value of the joystick is within the dead zone, return 0
	{
		return 0;
	}
	else															// Otherwise return the joystick value multiplied by the ratio
	{
		return ratio * joyVal;
	}
}

void moveArm(int height)
{
	// This function is used to raise or lower the arm to a designated height
	bool   done = false;
	while (done == false)
	{
		if (nMotorEncoder[motorLift1] < height)							  	// If the arm is below the designated height
		{
			nMotorEncoderTarget[motorLift1] = height;					 	 // Set the motor encoder target for the arm to the designated height
			motor[motorLift1] = -armSpeed;                       // Raise the arm at the designated speed

			while(nMotorRunState[motorLift1] != runStateIdle)  	 // While the arm is still moving (hasn't reached the target yet)
			{
				// Do not continue
			}
			motor[motorLift1] = 0;                    					   // Once the arm has reached its target, stop moving

			done = true;																						// Stop the function
		}

		else if (nMotorEncoder[motorLift1] > height)					// If the arm is above the designated height
		{
			nMotorEncoderTarget[motorLift1] = height;        			// Set the motor encoder target for the arm to the designated height
			motor[motorLift1] = armSpeed;                     	 	// Lower the arm

			while (nMotorRunState[motorLift1] != runStateIdle)   // While the arm is still moving (hasn't reached target yet)
			{
				// Do not continue
			}

			motor[motorLift1] = 0;                       				// When the target is reached, stop moving the arm

			done = true;																				// Stop the function
		}
	}
}

void go_forward(int speed)					// Function for moving the robot forward at a certain speed
{
	motor[motorFL] = speed;						// All motors go forward at the inputted speed
	motor[motorFR] = speed;
	motor[motorBR] = speed;
	motor[motorBL] = speed;
	nxtDisplayTextLine(5,"forward");  // Display "forward" on the NXT screen
}

void go_backward(int speed)			// Function for moving the robot backward at a certain speed
{
	motor[motorFL] = -speed;			// All motors go backward at the inputted speed
	motor[motorFR] = -speed;
	motor[motorBR] = -speed;
	motor[motorBL] = -speed;
	nxtDisplayTextLine(5,"backward");		// Display "backward" on the NXT screen
}

void strafe_left(int speed)			// Function for strafing the robot left at a certain speed
{
	motor[motorFL] = -speed;			// Motors FL and BR go backward at the inputted speed
	motor[motorFR] = speed;				// Motors FR and BL go forward at the inputted speed
	motor[motorBR] = -speed;
	motor[motorBL] = speed;
	nxtDisplayTextLine(5,"strafe left"); 	// Display "strafe left" on the NXT screen
}

void strafe_right(int speed)		// Function for strafing the robot right at a certain speed
{
	motor[motorFL] = speed;				// Motors FL and BR go forward at the inputted speed
	motor[motorFR] = -speed;			// Motors FR and BL go backward at the inputted speed
	motor[motorBR] = speed;
	motor[motorBL] = -speed;
	nxtDisplayTextLine(5,"strafe right");	// Display "strafe right" on the NXT screen
}

void strafe_forward_right(int speed)	// Function for strafing the robot diagonally forward and to the right at a certain speed
{
	motor[motorFL] = speed;				// Motors FL and BR go forward at the inputted speed
	motor[motorFR] = 0;						// Motors FR and BL don't move
	motor[motorBR] = speed;
	motor[motorBL] = 0;
	nxtDisplayTextLine(5,"forward right");	// Display "forward right" on the NXT screen
}

void strafe_backward_right(int speed)	// Function for strafing the robot diagonally backward and to the right at a certain speed
{
	motor[motorFL] = 0;						// Motors FL and BR don't move
	motor[motorFR] = -speed;			// Motors FR and BL go backward at the inputted speed
	motor[motorBR] = 0;
	motor[motorBL] = -speed;
	nxtDisplayTextLine(5,"backward right");	// Display "backward right" on the NXT screen
}

void strafe_backward_left(int speed)	// Function for strafing the robot diagonally backward and to the left at a certain speed
{
	motor[motorFL] = -speed;			// Motors FL and BR go backward at the inputted speed
	motor[motorFR] = 0;						// Motors FR and BL don't move
	motor[motorBR] = -speed;
	motor[motorBL] = 0;
	nxtDisplayTextLine(5,"backward left");	// Display "backward left" on the NXT screen
}

void strafe_forward_left(int speed)		// Function for strafing the robot diagonally forward and to the left at a certain speed
{
	motor[motorFL] = 0;						// Motors FL and BR don't move
	motor[motorFR] = speed;				// Motors FR and BL go forward at the inputted speed
	motor[motorBR] = 0;
	motor[motorBL] = speed;
	nxtDisplayTextLine(5,"forward left");	// Display "forward left" on the NXT screen
}

void rotate_clockwise(int speed)		// Function for rotating the robot clockwise at a certain speed
{
	motor[motorFL] = -speed;			// Motors FL and BR go backward at the inputted speed
	motor[motorFR] = speed;				// Motors FR and BL go forward at the inputted speed
	motor[motorBR] = speed;
	motor[motorBL] = -speed;
	nxtDisplayTextLine(5,"clockwise");		// Display "clockwise" on the NXT screen
}

void rotate_counter_clockwise(int speed)	// Function for rotating the robot counter-clockwise at a certain speed
{
	motor[motorFL] = speed;					// Motors FL and BR go forward at the inputted speed
	motor[motorFR] = -speed;				// Motors FR and BL go backward at the inputted speed
	motor[motorBR] = -speed;
	motor[motorBL] = speed;
	nxtDisplayTextLine(5,"counter clockwise");	// Display "counter clockwise" on the NXT screen
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	waitForStart();											// Wait for the tele-op period to begin
	nMotorEncoder(motorLift1) = 0;			// Reset the motor encoders for the arm
	servoTarget(clawL) = 225;						// Initialize the claw to be open
	servoTarget(clawR) = 60;
	PlaySoundFile("Leroy.rso");					// Shout "LEEROY JENKINS!", just for fun
	wait1Msec(10);											// Wait one tenth of a second

	while (true)
	{
		getJoystickSettings(joystick);																	 // Read the value of the joysticks
		nxtDisplayTextLine(6, "Encoder: %d", nMotorEncoder[motorLift1]); // Display the value of the arm encoder


		// The following code makes the directional pad on controller 1 give precise digital control of the drivetrain:

		if (joystick.joy1_TopHat == 0)				// If "up" on the directional pad is pressed:
		{
			go_forward(25);											// Go forward at 25% speed
		}

		else if (joystick.joy1_TopHat == 1)		// Else if "top right" on the directional pad is pressed:
		{
			strafe_forward_right(25);						// Strafe diagonally forward and to the right at 25% speed
		}

		else if (joystick.joy1_TopHat == 2)		// Else if "right" on the directional pad is pressed:
		{
			strafe_right(25);										// Strafe to the right at 25% speed
		}

		else if (joystick.joy1_TopHat == 3)		// Else if "bottom right" on the directional pad is pressed:
		{
			strafe_backward_right(25);					// Strafe diagonally backward and to the right 25% speed
		}

		else if (joystick.joy1_TopHat == 4)		// Else if "down" on the directional pad is pressed:
		{
			go_backward(25);										// Go backward 25% speed
		}

		else if (joystick.joy1_TopHat == 5)		// Else if "bottom left" on the directional pad is pressed:
		{
			strafe_backward_left(25);						// Strafe diagonally backward and to the left 25% speed
		}

		else if (joystick.joy1_TopHat == 6)		// Else if "left" on the directional pad is pressed:
		{
			strafe_left(25);										// Strafe left 25% speed
		}

		else if (joystick.joy1_TopHat == 7)		// Else if "top left" on the directional pad is pressed:
		{
			strafe_forward_left(25);						// Strafe diagonally forward and to the left 25% speed
		}

		else if (joy1Btn(5))									// Else if button 6 is pressed:
		{
			rotate_clockwise(25);								// Rotate the robot clockwise 25% speed
		}

		else if (joy1Btn(6))									// Else if button 5 is pressed:
		{
			rotate_counter_clockwise(25);				// Rotate the robot counter-clockwise 25% speed
		}

		// The following code makes the joysticks on controller 1 give analogue control of the drivetrain:

		else
		{
			motor[motorFL] = scale_motor(joystick.joy1_y1 + joystick.joy1_x1 + joystick.joy1_x2);		// Scale the motors to the average
			motor[motorFR] = scale_motor(joystick.joy1_y1 + -joystick.joy1_x1 - joystick.joy1_x2);	//of the left joystick Y value and
			motor[motorBR] = scale_motor(joystick.joy1_y1 + joystick.joy1_x1 - joystick.joy1_x2);		//the right joystick X value
			motor[motorBL] = scale_motor(joystick.joy1_y1 + -joystick.joy1_x1 + joystick.joy1_x2);
		}

		// The following code assigns the shoulder buttons on controller 2 to open and close the claw:

		if (joy2Btn(5))
		{
			servoTarget(clawL) = 55; 	// If button 5 is pressed on controller 2, close the claw
			servoTarget(clawR) = 170;
		}
		else if (joy2Btn(6))
		{
			servoTarget(clawL) = 115;	// If button 6 is pressed on controller 2, open the claw
			servoTarget(clawR) = 100;
		}
		else if (joy2Btn(8))
		{
			servoTarget(clawL) = ServoValue(clawL) + 1;	 // While button 7 is held, slowly close the claw
			servoTarget(clawR) = ServoValue(clawR) - 1;
		}
		else if (joy2Btn(7))
		{
			servoTarget(clawL) = ServoValue(clawL) - 1;  // While button 8 is held, slowly open the claw
			servoTarget(clawR) = ServoValue(clawR) + 1;
		}
		else
		{
			servoTarget(clawL) = ServoValue(clawL);		   // Otherwise, do not move the claw
			servoTarget(clawR) = ServoValue(clawR);
		}

		// The following code gives analogue control of the arm with the joystick, and assigns buttons 1-4 to move the arm to their respective rows on the scoring rack

		if (joy2Btn(1))					// If button 1 is pressed, move the arm to the lowest row on the scoring rack
		{
			moveArm(level1Value);
		}
		else if (joy2Btn(2))		// If button 2 is pressed, move the arm to the middle row on the scoring rack
		{
			moveArm(level2Value);
		}
		else if (joy2Btn(3))		// If button 3 is pressed, move the arm to the top row on the scoring rack
		{
			moveArm(level3Value);
		}
		else if (joy2Btn(4))		// If button 4 is pressed, lower the arm all the way
		{
			moveArm(0);
		}
		else
		{
			motor[motorLift1] = (joystick.joy2_y1 / 12);		// Otherwise, control the arm with joystick 1 on controller 2
			motor[motorLift1] = (joystick.joy2_y1 / 24);		// Or control the arm at half speed with joystick 2 on controller 2
																											// Note: these values are divided by 12 and 24 to bring the arm speed down to a reasonable level
		}
	}
}
