#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     irSensor1,      sensorI2CCustom)
#pragma config(Sensor, S3,     irSensor2,      sensorI2CCustom)
#pragma config(Sensor, S4,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     motorFL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorFR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorBR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorLift1,    tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    clawL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    clawR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: During the autonomous period, the robot will strafe parallel to the scoring rack until it is lined up with the IR beacon.   //
// Once this is accomplished, it will drive forward and place the ring onto the scoring rack, then reverse away from the rack.          //
// Contributors: Kyle Hall, Grant Matthews, Warren Li, Tom Sarsfield                                                                    //
// Last Date Edited: 2/22/2013                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "C:\Program Files (x86)\Robomatter Inc\ROBOTC Development Environment\3rd party drivers\rdpartyrobotcdr-3.0\drivers\hitechnic-gyro.h"
#include "C:\Program Files (x86)\Robomatter Inc\ROBOTC Development Environment\3rd party drivers\rdpartyrobotcdr-3.0\drivers\hitechnic-irseeker-v2.h"
#include "JoystickDriver.c";
// These are the drivers required to run the program

////////////////////////
// Global Variables:  //
////////////////////////

int armSpeed = 50;						// The speed at which to move the arm
int time;											// A count of how long the program has been running
int scoringPegHeight = -3100; // The height of the scoring peg in encoder ticks (can vary between fields)

////////////////////////
// Global Functions:  //
////////////////////////

int read_total()
{
	// This function adds together the values of the two IR sensors (1-9, based on the direction of the beacon) for triangulation purposes
	int direction1 = HTIRS2readACDir(irSensor1);
	int direction2 = HTIRS2readACDir(irSensor2);
	int total = direction1 + direction2;
	return total;
}

task counter()
{
	// This task counts in milliseconds how long it takes to strafe to the beacon, and displays it on the NXT screen
	while(true)
	{
		wait1Msec(1);
		time = time + 1;
		nxtDisplayTextLine(0, "Time: %d", time);
	}
}

void strafeToIR()
{
	// This function triangulates the position of the IR beacon, then strafes left or right until the robot is directly facing it
	bool done = 0;
	while(done == 0)
	{
		switch(read_total())			// This switch statement considers every possible value that could be returned from the two IR sensors, and
		{													//designates which direction to move based on it
		case 1:										// If a value of 1 is returned, strafe left at 100% speed
			motor[motorFL] = -100;
			motor[motorFR] = 100;
			motor[motorBR] = -100;
			motor[motorBL] = 100;
			break;
		case 2:										// If a value of 2 is returned, strafe left at 100% speed
			motor[motorFL] = -100;
			motor[motorFR] = 100;
			motor[motorBR] = -100;
			motor[motorBL] = 100;
			break;
		case 3:										// If a value of 3 is returned, strafe left at 88% speed
			motor[motorFL] = -88;
			motor[motorFR] = 88;
			motor[motorBR] = -88;
			motor[motorBL] = 88;
			break;
		case 4:										// If a value of 4 is returned, strafe left at 75% speed
			motor[motorFL] = -75;
			motor[motorFR] = 75;
			motor[motorBR] = -75;
			motor[motorBL] = 75;
			break;
		case 5:										// If a value of 5 is returned, strafe left at 63% speed
			motor[motorFL] = -63;
			motor[motorFR] = 63;
			motor[motorBR] = -63;
			motor[motorBL] = 63;
			break;
		case 6:										// If a value of 6 is returned, strafe left at 50% speed
			motor[motorFL] = -50;
			motor[motorFR] = 50;
			motor[motorBR] = -50;
			motor[motorBL] = 50;
			break;
		case 7:										// If a value of 7 is returned, strafe left at 38% speed
			motor[motorFL] = -38;
			motor[motorFR] = 38;
			motor[motorBR] = -38;
			motor[motorBL] = 38;
			break;
		case 8:										// If a value of 8 is returned, strafe left at 25% speed
			motor[motorFL] = -25;
			motor[motorFR] = 25;
			motor[motorBR] = -25;
			motor[motorBL] = 25;
			break;
		case 9:										// If a value of 9 is returned, strafe left at 25% speed
			motor[motorFL] = -25;
			motor[motorFR] = 25;
			motor[motorBR] = -25;
			motor[motorBL] = 25;
			break;
		case 10:									// If a value of 10 is returned, stop the robot, end the function, and stop timing the program
			motor[motorFL] = 0;
			motor[motorFR] = 0;
			motor[motorBR] = 0;
			motor[motorBL] = 0;
			done = true;
			StopTask(counter);
			break;
		case 11:									// If a value of 11 is returned, strafe right at 25% speed
			motor[motorFL] = 25;
			motor[motorFR] = -25;
			motor[motorBR] = 25;
			motor[motorBL] = -25;
			break;
		case 12:									// If a value of 12 is returned, strafe right at 25% speed
			motor[motorFL] = 25;
			motor[motorFR] = -25;
			motor[motorBR] = 25;
			motor[motorBL] = -25;
			break;
		case 13:									// If a value of 13 is returned, strafe right at 38% speed
			motor[motorFL] = 38;
			motor[motorFR] = -38;
			motor[motorBR] = 38;
			motor[motorBL] = -38;
			break;
		case 14:									// If a value of 14 is returned, strafe right at 50% speed
			motor[motorFL] = 50;
			motor[motorFR] = -50;
			motor[motorBR] = 50;
			motor[motorBL] = -50;
			break;
		case 15:									// If a value of 15 is returned, strafe right at 63% speed
			motor[motorFL] = 63;
			motor[motorFR] = -63;
			motor[motorBR] = 63;
			motor[motorBL] = -63;
			break;
		case 16:									// If a value of 16 is returned, strafe right at 75% speed
			motor[motorFL] = 75;
			motor[motorFR] = -75;
			motor[motorBR] = 75;
			motor[motorBL] = -75;
			break;
		case 17:									// If a value of 17 is returned, strafe right at 88% speed
			motor[motorFL] = 88;
			motor[motorFR] = -88;
			motor[motorBR] = 88;
			motor[motorBL] = -88;
			break;
		case 18:									// If a value of 18 is returned, strafe right at 100% speed
			motor[motorFL] = 100;
			motor[motorFR] = -100;
			motor[motorBR] = 100;
			motor[motorBL] = -100;
			break;
		default:									// Otherwise, don't move
			motor[motorFL] = 0;
			motor[motorFR] = 0;
			motor[motorBR] = 0;
			motor[motorBL] = 0;
			break;
		}
	}
}

void finalStep()
{
	// This function determines what to do after the ring has been placed, based on which column the ring was placed on
	if (time < 4000)
	{
		motor[motorFL] = 100;		// Rotate the robot 90 degrees to face the ring dispenser
		motor[motorFR] = -100;
		motor[motorBR] = -100;
		motor[motorBL] = 100;
		wait1Msec(250);

		motor[motorFL] = 100;		// Rotate the robot 90 degrees to face the ring dispenser
		motor[motorFR] = 100;
		motor[motorBR] = 100;
		motor[motorBL] = 100;
		wait1Msec(500);
	}
	else if (time > 4000)
	{
		motor[motorFL] = -100;		// Rotate the robot 90 degrees to face the ring dispenser
		motor[motorFR] = 100;
		motor[motorBR] = 100;
		motor[motorBL] = -100;
		wait1Msec(1000);
	}
}



task main()
{
	// This task dictates what the robot will do during the autonomous period

	waitForStart();									// Wait for the start of the autonomous period
	StartTask(counter);							// Begin timing the program, for use later
	PlaySoundFile("Leroy.rso");			// Shout "LEEROY JENKINS!", just for fun
	nMotorEncoder(motorLift1) = 0;	// Reset the motor encoders for the arm
	servoTarget(clawL) = 55; 				// Close the claw to hold the ring
	servoTarget(clawR) = 170;
	wait1Msec(100);									// Wait a tenth of a second

	strafeToIR();				// Strafe parallel to the scoring rack until it is lined up with the IR beacon
	wait1Msec(1000);		// Wait for one second after this has been completed

	strafeToIR();				// Strafe parallel to the scoring rack until it is lined up with the IR beacon
	wait1Msec(1000);		// Wait for one second after this has been completed
											// Note: this is done twice to ensure accuracy

	motor[motorFL] = 0;	// Wait one tenth of a second in the stopped position
	motor[motorFR] = 0;
	motor[motorBR] = 0;
	motor[motorBL] = 0;
	wait1Msec(100);

	// The following code is used to raise the arm to the correct height:

	nMotorEncoderTarget[motorLift1] = -scoringPegHeight; // Set the motor encoder target for the arm to the height of the scoring peg
	motor[motorLift1] = -armSpeed;                       // Raise the arm at the designated speed

	while(nMotorRunState[motorLift1] != runStateIdle)  	 // While the arm is still moving (hasn't reached the target yet)
	{
																											 // Do not continue
	}
	motor[motorLift1] = 0;                    				   // Once the arm has reached its target, stop moving

	motor[motorFL] = 100;			// Drive forward towards the scoring rack
	motor[motorFR] = 100;
	motor[motorBR] = 100;
	motor[motorBL] = 100;
	wait1Msec(3000);

	motor[motorFL] = 0;				// Wait one second in the stopped position
	motor[motorFR] = 0;
	motor[motorBR] = 0;
	motor[motorBL] = 0;
	wait1Msec(1000);

	servoTarget(clawL) = 115;	// Open the claw to place the ring on the scoring rack
	servoTarget(clawR) = 100;
	wait1Msec(1000);

	motor[motorFL] = -100;		// Reverse away from the scoring rack, leaving the ring on the rack
	motor[motorFR] = -100;
	motor[motorBR] = -100;
	motor[motorBL] = -100;
	wait1Msec(1800);

	motor[motorFL] = 0;				// Wait one second in the stopped position
	motor[motorFR] = 0;
	motor[motorBR] = 0;
	motor[motorBL] = 0;
	wait1Msec(1000);

	servoTarget(clawL) = 55; 	// Close the claw
	servoTarget(clawR) = 170;
	wait1Msec(1000);

	// The following code is used to lower the arm back down:

	nMotorEncoderTarget[motorLift1] = 100;     			  // Set the motor encoder target for the arm to the height of the scoring peg
	motor[motorLift1] = armSpeed;                     // Raise the arm at the designated speed

	while(nMotorRunState[motorLift1] != runStateIdle) // While the arm is still moving (hasn't reached the target yet)
	{
																										// Do not continue
	}
	motor[motorLift1] = 0;                        		// Once the arm has reached its target, stop moving
}
