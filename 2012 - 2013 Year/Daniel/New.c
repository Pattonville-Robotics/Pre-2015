#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftmotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightmotor,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    leftservo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    rightservo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    bucketservo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard
#include <JoystickDriver.c>
#include <hitechnic-sensormux.h>
#include <hitechnic-irseeker-v2.h>
#include <hitechnic-gyro.h>
#include <hitechnic-touchmux.h>


const tMUXSensor irseeker = msensor_S2_1;
const tMUXSensor lineSensor = msensor_S2_2;
const tMUXSensor touchSensor = msensor_S2_3;
const tMUXSensor gyroSensor = msensor_S2_4;

float happy_angle=0;

task update_gyroSensor()
{
	HTGYROstartCal(gyroSensor);
	while(true)
	{
		float angle=HTGYROreadRot(gyroSensor)/100.0;
		happy_angle=happy_angle+angle;
		nxtDisplayTextLine(7, "%d", happy_angle);
		wait1Msec (10);
	}
}

const float scaleFactor = 0.45;

int readIR()
{
	int IRValue = HTIRS2readACDir(irseeker);
	return IRValue;
}

//bool alignWithBeacon = false;

void followIR()
{
	if (readIR()< 5 && readIR()>0)
	{
		motor[leftmotor]=-100;
		motor[rightmotor]=100;
		nxtDisplayTextLine(3,"Left");
	}
	else if (readIR()> 5)
	{
		motor[leftmotor]=100;
		motor[rightmotor]=100;
		nxtDisplayTextLine(3,"Right");
	}
	else if (readIR()== 5)
	{
		motor[leftmotor]=100;
		motor[rightmotor]=100;

		nxtDisplayTextLine(3,"Forward");
	}
	else
	{
		motor[leftmotor]=0;
		motor[rightmotor]=0;

		nxtDisplayTextLine(3,"Stop");
	}
}

bool isOnLine()
{
	if(SensorValue[lineSensor] > 45)
	{
		return true;
	}
	else
	{
		return false;
	}

}

bool bumperIsPressed()
{
	if(SensorValue(touchSensor) == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool inLineWithGoal()
{
	if(isOnLine() == true && SensorValue[irseeker] == 4)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void driveUntilBumper(int motorSpeed)
{
	while(SensorValue[touchSensor] == false)
	{
		motor[leftmotor] = motorSpeed * scaleFactor;
		motor[rightmotor] = motorSpeed;
	}
}

void driveUntilIR(int irValue, int motorSpeed)
{
	while(readIR() != irValue)
	{
		motor[leftmotor] = motorSpeed * scaleFactor;
		motor[rightmotor] = motorSpeed;
	}
}

void driveUntilIRNot(int irValue, int motorSpeed)
{
	while(readIR() == irValue)
	{
		motor[leftmotor] = motorSpeed * scaleFactor;
		motor[rightmotor] = motorSpeed;
	}
}
//Does anyone actualy read these comments
void turnToAngle(int motorSpeedTurn, int motorSpeedForward, int angle)
{
	bool turningRight = false;
	if(happy_angle < angle)
	{
		turningRight = true;
	}
	if(turningRight == true)
	{
		while(happy_angle < angle)
		{
			motor[leftmotor] = motorSpeedForward + motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward - motorSpeedTurn;
		}
	}
	else //Turning left
	{
		while(happy_angle > angle)
		{
			motor[leftmotor] = motorSpeedForward - motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward + motorSpeedTurn;
		}
	}
}



/*
Go strait until bumper pressed X
Determine placement of IR beacon
Read gyro x>z
Backup turing right until gyro is less than 90 X
Drive forward until IR == 8 or 9
Turn right 90 degrees
Lift
drive forward
Place scoring element
Drive back and lower slides


void USSRNationalAnthem()
{
	//        250 = Tempo
	//          5 = Default octave
	//    Quarter = Default note length
	//        10% = Break between notes
	//
	PlayTone( 1047,   22); wait1Msec( 240);  // Note(F6)
	PlayTone( 1398,   43); wait1Msec( 480);  // Note(A#6, Duration(Half))
	PlayTone( 1047,   32); wait1Msec( 360);  // Note(F6, Duration(Quarter .))
	PlayTone( 1175,   11); wait1Msec( 120);  // Note(G6, Duration(Eighth))
	PlayTone( 1320,   43); wait1Msec( 480);  // Note(A6, Duration(Half))
	PlayTone(  880,   22); wait1Msec( 240);  // Note(D6)
	PlayTone(  880,   22); wait1Msec( 240);  // Note(D6)
	PlayTone( 1175,   43); wait1Msec( 480);  // Note(G6, Duration(Half))
	PlayTone( 1047,   32); wait1Msec( 360);  // Note(F6, Duration(Quarter .))
	PlayTone(  933,   11); wait1Msec( 120);  // Note(D#6, Duration(Eighth))
	PlayTone( 1047,   43); wait1Msec( 480);  // Note(F6, Duration(Half))
	PlayTone(  932,   32); wait1Msec( 360);  // Note(A#, Duration(Quarter .))
	PlayTone(  932,   11); wait1Msec( 120);  // Note(A#, Duration(Eighth))
	PlayTone(  784,   43); wait1Msec( 480);  // Note(C6, Duration(Half))
	PlayTone(  784,   32); wait1Msec( 360);  // Note(C6, Duration(Quarter .))
	PlayTone(  880,   11); wait1Msec( 120);  // Note(D6, Duration(Eighth))
	PlayTone(  933,   43); wait1Msec( 480);  // Note(D#6, Duration(Half))
	PlayTone(  933,   22); wait1Msec( 240);  // Note(D#6)
	PlayTone( 1047,   22); wait1Msec( 240);  // Note(F6)
	PlayTone( 1175,   43); wait1Msec( 480);  // Note(G6, Duration(Half))
	PlayTone( 1320,   32); wait1Msec( 360);  // Note(A6, Duration(Quarter .))
	PlayTone( 1398,   11); wait1Msec( 120);  // Note(A#6, Duration(Eighth))
	PlayTone(  784,   65); wait1Msec( 720);  // Note(C6, Duration(Half .))
	PlayTone( 1047,   22); wait1Msec( 240);  // Note(F6)
	PlayTone(  880,   43); wait1Msec( 480);  // Note(D6, Duration(Half))
	PlayTone(  784,   32); wait1Msec( 360);  // Note(C6, Duration(Quarter .))
	PlayTone( 1398,   11); wait1Msec( 120);  // Note(A#6, Duration(Eighth))
	PlayTone(  784,   43); wait1Msec( 480);  // Note(C6, Duration(Half))
	PlayTone( 1320,   22); wait1Msec( 240);  // Note(A6)
	PlayTone( 1047,   22); wait1Msec( 240);  // Note(F6)
	PlayTone( 1398,   43); wait1Msec( 480);  // Note(A#6, Duration(Half))
	PlayTone( 1320,   32); wait1Msec( 360);  // Note(A6, Duration(Quarter .))
	PlayTone( 1175,   11); wait1Msec( 120);  // Note(G6, Duration(Eighth))
	PlayTone( 1320,   43); wait1Msec( 480);  // Note(A6, Duration(Half))
	PlayTone(  880,   22); wait1Msec( 240);  // Note(D6)
	PlayTone(  880,   22); wait1Msec( 240);  // Note(D6)
	PlayTone( 1175,   43); wait1Msec( 480);  // Note(G6, Duration(Half))
	PlayTone( 1047,   32); wait1Msec( 360);  // Note(F6, Duration(Quarter .))
	PlayTone(  933,   11); wait1Msec( 120);  // Note(D#6, Duration(Eighth))
	PlayTone( 1047,   43); wait1Msec( 480);  // Note(F6, Duration(Half))
	PlayTone(  932,   32); wait1Msec( 360);  // Note(A#, Duration(Quarter .))
	PlayTone(  932,   11); wait1Msec( 120);  // Note(A#, Duration(Eighth))
	PlayTone( 1398,   43); wait1Msec( 480);  // Note(A#6, Duration(Half))
	PlayTone( 1320,   32); wait1Msec( 360);  // Note(A6, Duration(Quarter .))
	PlayTone( 1175,   11); wait1Msec( 120);  // Note(G6, Duration(Eighth))
	PlayTone( 1047,   86); wait1Msec( 960);  // Note(F6, Duration(Whole))
	PlayTone(  880,   86); wait1Msec( 960);  // Note(D6, Duration(Whole))
	PlayTone(  784,   22); wait1Msec( 240);  // Note(C6)
	PlayTone( 1398,   22); wait1Msec( 240);  // Note(A#6)
	PlayTone( 1320,   22); wait1Msec( 240);  // Note(A6)
	PlayTone( 1398,   22); wait1Msec( 240);  // Note(A#6)
	PlayTone(  784,   65); wait1Msec( 720);  // Note(C6, Duration(Half .))
	PlayTone( 1047,   22); wait1Msec( 240);  // Note(F6)
	PlayTone( 1047,   65); wait1Msec( 720);  // Note(F6, Duration(Half .))
	PlayTone( 1398,   86); wait1Msec( 960);  // Note(A#6, Duration(Whole))
	PlayTone( 1320,   22); wait1Msec( 240);  // Note(A6)
	PlayTone( 1175,   22); wait1Msec( 240);  // Note(G6)
	PlayTone( 1047,   22); wait1Msec( 240);  // Note(F6)
	PlayTone( 1175,   22); wait1Msec( 240);  // Note(G6)
	PlayTone( 1320,   65); wait1Msec( 720);  // Note(A6, Duration(Half .))
	PlayTone(  880,   22); wait1Msec( 240);  // Note(D6)
	PlayTone(  880,   43); wait1Msec( 480);  // Note(D6, Duration(Half))
	return;
}*/


task Play()
{
	//USSRNationalAnthem();
}



task main()
{
	int IRState;
	StartTask (Play);
	StartTask (update_gyroSensor);
	driveUntilIRNot(5, 40);//Adjust later
	IRState = readIR();
	driveUntilIR(0, 40);
	driveUntilBumper(15);//Adjust later
	if(IRState == 4)
	{
		turnToAngle( -40, -60, -90);
	}
	else
	{
		turnToAngle( 40, -60, 90);
	}
	if(IRState > 5)
	{
		driveUntilIR(1, 40);
		turnToAngle(-40, -0, 0);
		driveUntilBumper(15);
		//PlayDuckDuckGoose();
	}
	else if(IRState < 5)
	{
		driveUntilIR(9, 40);
		turnToAngle(40, 0, 0);
		driveUntilBumper(15);
	}
	else
	{
		driveUntilIR(0,40);
	}


	//turnToAngle(40, 60, 90);
	//driveUntilIR();
}
