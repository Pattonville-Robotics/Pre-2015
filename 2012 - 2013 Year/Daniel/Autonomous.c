#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S3,     irseeker,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rightmotor,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightslidemotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     leftmotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     leftslidemotor, tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    bucketservo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <JoystickDriver.c>
#include <hitechnic-sensormux.h>
#include <hitechnic-irseeker-v2.h>
#include <hitechnic-gyro.h>
#include <hitechnic-touchmux.h>
//These are the drivers required for handling


const tMUXSensor lineSensor = msensor_S2_2;
const tMUXSensor touchSensor = msensor_S2_3;
const tMUXSensor gyroSensor = msensor_S2_4;
//These three lines declare the sensors that we are running through the sensor multiplexor

float happy_angle=0;

task update_gyroSensor()
{
	HTGYROstartCal(gyroSensor);
	while(true)
	{
		float angle=HTGYROreadRot(gyroSensor)/100.0;
		happy_angle=happy_angle+angle;
		nxtDisplayTextLine(7, "%d", happy_angle);
		wait1Msec (10);
	}
}

void driveStraight (int motorSpeed, int angle)//Drives straight at an angle. 
{
		motor[leftmotor] = motorSpeed;
		motor[rightmotor] = motorSpeed;
		if (happy_angle < 3 && happy_angle > -3)//while straight go straight
		{
			nxtDisplayTextLine(6, "Going Straight");
			motor[rightmotor]=motorSpeed;
			motor[leftmotor]=motorSpeed;
		}
		if (happy_angle>3)// while rightmotor go leftmotor
		{
			nxtDisplayTextLine(6, "Going leftmotor");
			motor[rightmotor]=motorSpeed * 0.7;
			motor[leftmotor]=motorSpeed;
		}
		if (happy_angle<-3)// while leftmotor go rightmotor
		{
			nxtDisplayTextLine(6, "Going rightmotor");

			motor[leftmotor]=motorSpeed;
			motor[rightmotor]=motorSpeed * 0.7;
		}
}

void raiseBucket() //This function allows us to raise the linear slides in order to score.
{
	motor[leftslidemotor]=100;
	motor[rightslidemotor]=100;
	wait10Msec(75);
	motor[leftslidemotor]=0;
	motor[rightslidemotor]=0;
}

void goStraightForTime(int time, int speed)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{
	time1[T1] = 0;//Creating the aforementioned timer
	while (time1[T1] < time)//While loop saying that while the value of the timer is less than the value of the parametrically set stop time.
	{
		driveStraight (speed, 0);//Drivers forward with no angle change (the null value is set in the parameters)
	}
}

task main()//Main task. Execution starts here.
{
	waitForStart();//Waiting for the start command from FCS, as sanctioned by the Game Manual
	raiseBucket();//Raise the bucket to the height of the first row of pegs (for value, see the "raiseBucket" void function)

	int IRState; //Gets value from the IR
	//StartTask (Play);
	StartTask (update_gyroSensor);

  goStraightForTime(4000, 40);
  goStraightForTime(500, 20);
  goStraightForTime(500, 10);

}