#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S3,     irseeker,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rightmotor,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightslidemotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     leftmotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     leftslidemotor, tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    bucketservo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <JoystickDriver.c>
#include <hitechnic-sensormux.h>
#include <hitechnic-irseeker-v2.h>
#include <hitechnic-gyro.h>
#include <hitechnic-touchmux.h>




//const tMUXSensor lineSensor = msensor_S2_2;
const tMUXSensor touchSensor = msensor_S2_3;
const tMUXSensor gyroSensor = msensor_S2_2;

float happy_angle=0;

task update_gyroSensor()
{
	HTGYROstartCal(gyroSensor);
	while(true)
	{
		float angle=HTGYROreadRot(gyroSensor)/100.0;
		happy_angle=happy_angle+angle;
		nxtDisplayTextLine(7, "%d", happy_angle);
		wait1Msec (10);
	}
}

int readIR()
{
	int IRValue = HTIRS2readACDir(irseeker);
	return IRValue;
}

int readLight()
{
	int lineSensor = SensorValue(lineSensor);
	return lineSensor;
}


//bool alignWithBeacon = false;

void followIR()
{
	if (readIR()< 5 && readIR()>0)
	{
		motor[leftmotor]=-100;
		motor[rightmotor]=100;
		nxtDisplayTextLine(3,"Left");
	}
	else if (readIR()> 5)
	{
		motor[leftmotor]=100;
		motor[rightmotor]=100;
		nxtDisplayTextLine(3,"Right");
	}
	else if (readIR()== 5)
	{
		motor[leftmotor]=100;
		motor[rightmotor]=100;

		nxtDisplayTextLine(3,"Forward");
	}
	else
	{
		motor[leftmotor]=0;
		motor[rightmotor]=0;

		nxtDisplayTextLine(3,"Stop");
	}
}

bool isOnLine()
{
	if(SensorValue[lineSensor] > 45)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool bumperIsPressed()
{
	if(SensorValue(touchSensor) == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool inLineWithGoal()
{
	if(isOnLine() == true && SensorValue[irseeker] == 4)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void driveStraight (int motorSpeed, int angle)
{
		motor[leftmotor] = motorSpeed;
		motor[rightmotor] = motorSpeed;
		if (happy_angle < 3 && happy_angle > -3)//while straight go straight
		{
			nxtDisplayTextLine(6, "Going Straight");
			motor[rightmotor]=motorSpeed;
			motor[leftmotor]=motorSpeed;
		}
		if (happy_angle>3)// while rightmotor go leftmotor
		{
			nxtDisplayTextLine(6, "Going leftmotor");
			motor[rightmotor]=motorSpeed * 0.7;
			motor[leftmotor]=motorSpeed;
		}
		if (happy_angle<-3)// while leftmotor go rightmotor
		{
			nxtDisplayTextLine(6, "Going rightmotor");

			motor[leftmotor]=motorSpeed;
			motor[rightmotor]=motorSpeed * 0.7;
		}
}

void driveUntilBumper(int motorSpeed) //Drives until the value of the sensor indicates a press.
{
	while(SensorValue[touchSensor] == false)
	{
		motor[leftmotor] = motorSpeed;
		motor[rightmotor] = motorSpeed;
	}
}

void driveUntilIR(int irValue, int motorSpeed)//Drives until the IR value equals a preset number.
{
	while(readIR() != irValue)
	{
     driveStraight (motorSpeed, 0);
	}
}

void driveUntilIRNot(int irValue, int motorSpeed)
{
	while(readIR() == irValue)
	{
     driveStraight (motorSpeed, 0);
	}
}

//Does anyone actualy read these comments

void turnToAngle(int motorSpeedTurn, int motorSpeedForward, int angle)
{
	bool turningRight = false;
	if(happy_angle < angle)
	{
		turningRight = true;
	}
	if(turningRight == true)
	{
		while(happy_angle < angle)
		{
			motor[leftmotor] = motorSpeedForward + motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward - motorSpeedTurn;
		}
	}
	else //Turning left
	{
		while(happy_angle > angle)
		{
			motor[leftmotor] = motorSpeedForward - motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward + motorSpeedTurn;
		}
	}
}
void turnUntilLine (int motorSpeedTurn,int motorSpeedForward, int angle)
{

	bool turningRight = false;
	if(happy_angle < angle)
	{
		turningRight = true;
	}
	if(turningRight == true)
	{
		while(happy_angle < angle)
		{
			motor[leftmotor] = motorSpeedForward + motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward - motorSpeedTurn;
		}
	}
	else //Turning left
	{
		while(happy_angle > angle)
		{
			motor[leftmotor] = motorSpeedForward - motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward + motorSpeedTurn;
		}
	}
}
/*
Go strait until bumper pressed X
Determine placement of IR beacon
Read gyro x>z
Backup turing right until gyro is less than 90 X
Drive forward until IR == 8 or 9
Turn right 90 degrees
Lift
drive forward
Place scoring element
Drive back and lower slides


task Play()
{
	PlaySoundFile (marcos_live_imperial_march.wav);
	wait10Msec(200);
}
*/

void raiseBucket()
{
	motor[leftslidemotor]=100;
	motor[rightslidemotor]=100;
	wait10Msec(75);
	motor[leftslidemotor]=0;
	motor[rightslidemotor]=0;
}

void goStraightForTime(int time, int speed)
{
	time1[T1] = 0;
	while (time1[T1] < time)
	{
		driveStraight (speed, 0);
	}
}

task main()
{
	waitForStart();
//	raiseBucket();

	int IRState; //Gets value from the IR
	//StartTask (Play);
	StartTask (update_gyroSensor);

  goStraightForTime(4000, 40);
  goStraightForTime(500, 20);
  goStraightForTime(500, 10);
/*
	driveUntilIRNot(5, 40);//Adjust later
	IRState = readIR();
	driveUntilIR(0, 40);

  driveUntilBumper(15);//Adjust later
	if(IRState == 4) // if IR is 4 then Turn
	{
		turnToAngle( -40, -60, -90);
	}
	else
	{
		turnToAngle( 40, -60, 90);
	}
	if(IRState > 5)
	{
		driveUntilIR(1, 40);
		turnToAngle(-40, -0, 0);
		driveUntilBumper(15);
	}
	else if(IRState < 5)
	{
		driveUntilIR(9, 40);
		turnToAngle(40, 0, 0);
		driveUntilBumper(15);
	}
	else
	{
		driveUntilIR(0,40);
	}
	//turnToAngle(40, 60, 90);
	//driveUntilIR();
	*/
}
