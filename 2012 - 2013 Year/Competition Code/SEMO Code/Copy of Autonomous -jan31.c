
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S4,     gyroSensor,     sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rightmotor,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftmotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     rightslidemotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftslidemotor, tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    bucketservo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <JoystickDriver.c>
#include <hitechnic-sensormux.h>
#include <hitechnic-irseeker-v2.h>
#include <hitechnic-gyro.h>
#include <hitechnic-touchmux.h>
#include <lego-light.h>
//These are the drivers required for handling


const tMUXSensor LightSensor = msensor_S2_1;
const tMUXSensor irseeker = msensor_S2_2;
//These three lines declare the sensors that we are running through the sensor multiplexor

const int leftColumn = 0;
const int midColumn = 1;
const int rightColumn = 2;
int columnNumber;

float happy_angle=0;

task update_gyroSensor()
{
	HTGYROstartCal(gyroSensor);
	while(true)
	{
		float angle=HTGYROreadRot(gyroSensor)/100.0;
		happy_angle=happy_angle+angle;
		nxtDisplayTextLine(7, "%d", happy_angle);
		wait1Msec (10);
	}
}

int readIR()
{
	int IRValue = HTIRS2readACDir(irseeker);
	return IRValue;
}


void printDebug()
{
	writeDebugStreamLine("Angle:%3d , IR: %d, LS:%4d", happy_angle, readIR(), LSvalRaw(LightSensor));
};

void driveStraight (int motorSpeed, int angle)//Drives straight at an angle.
{
	motor[leftmotor] = motorSpeed;
	motor[rightmotor] = motorSpeed;
	//if (happy_angle < 3 && happy_angle > -3)//while straight go straight
	//{
	//	nxtDisplayTextLine(6, "Going Straight");
	//	motor[rightmotor]=motorSpeed;
	//	motor[leftmotor]=motorSpeed;
	//}
	if (happy_angle<angle)// while rightmotor go leftmotor
	{
		nxtDisplayTextLine(6, "Going rightmotor");
		motor[rightmotor]=motorSpeed;
		motor[leftmotor]=motorSpeed;
	}
	else if (happy_angle>angle)// while leftmotor go rightmotor
	{
		nxtDisplayTextLine(6, "Going leftmotor");

		motor[rightmotor]=motorSpeed * 2;
		motor[leftmotor]=motorSpeed * 0.15;
	}
}

void driveBackwards(int motorSpeed, int angle)//Drives straight at an angle.
{
	motor[leftmotor] = motorSpeed;
	motor[rightmotor] = motorSpeed;
	//if (happy_angle < 3 && happy_angle > -3)//while straight go straight
	//{
	//	nxtDisplayTextLine(6, "Going Straight");
	//	motor[rightmotor]=motorSpeed;
	//	motor[leftmotor]=motorSpeed;
	//}
	if (happy_angle>angle)// while rightmotor go leftmotor
	{
		nxtDisplayTextLine(6, "Going rightmotor");
		motor[rightmotor]=motorSpeed;
		motor[leftmotor]=motorSpeed;
	}
	else if (happy_angle<angle)// while leftmotor go rightmotor
	{
		nxtDisplayTextLine(6, "Going leftmotor");

		motor[rightmotor]=motorSpeed * 2;
		motor[leftmotor]=motorSpeed * 0.15;
	}
}

void moveBucket(int distance)
{
	if (distance < 0)
	{
		servo[bucketservo] = 180;
	}
	else
	{
		servo[bucketservo] = 90;
	}
	wait1Msec(abs(distance) * 7);
	servo[bucketservo] = 128;
}

void raiseBucket() //This function allows us to raise the linear slides in order to score.
{
	motor[leftslidemotor]=100;
	motor[rightslidemotor]=100;
	wait10Msec(92);
	motor[leftslidemotor]=0;
	motor[rightslidemotor]=0;
}

void lowerBucket()
{
	motor[leftslidemotor]=-100;
	motor[rightslidemotor]=-100;
	wait10Msec(92);
	motor[leftslidemotor]=0;
	motor[rightslidemotor]=0;
};

void goStraightForTime(int time, int speed,int angle)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{
	time1[T1] = 0;//Creating the aforementioned timer
	while (time1[T1] < time)//While loop saying that while the value of the timer is less than the value of the parametrically set stop time.
	{
		printDebug();
		driveStraight (speed, angle);//Drivers forward with no angle change (the null value is set in the parameters)
	}
	writeDebugStreamLine("End goStraightForTime");
}

void goBackwardForTime(int time, int speed,int angle)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{
	time1[T1] = 0;//Creating the aforementioned timer
	while (time1[T1] < time)//While loop saying that while the value of the timer is less than the value of the parametrically set stop time.
	{
		printDebug();
		driveBackwards(speed, angle);//Drivers forward with no angle change (the null value is set in the parameters)
	}
	writeDebugStreamLine("End goStraightForTime");
}

void goStraightUntilLightChanges(int speed)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{

	servo[servo2]=127;
	int initValue = 0;
	int raw = 0;
	initValue = LSvalRaw(LightSensor)+20;
	raw = initValue;
	writeDebugStreamLine("  Initial Light:%d", initValue);
	while(abs(raw-initValue)<=30)//While loop saying that while the value of the light sensor is less than the value of the parametrically set stop value.
	{
		printDebug();
		raw = LSvalRaw(LightSensor);
		nxtDisplayCenteredBigTextLine(1, "%d", raw);
		driveStraight (speed, 0);//Drivers forward with no light sensor value change (the null value is set in the parameters)
	}
	motor[leftmotor]=0;
	motor[rightmotor]=0;
	printDebug();
	writeDebugStreamLine("Light Changed");
}

void turnToAngle(int motorSpeedTurn, int motorSpeedForward, int angle)
{
	bool turningRight = false;
	if(happy_angle < angle)
	{
		turningRight = true;
	}
	if(turningRight == true)
	{
		while(happy_angle < angle)
		{

			motor[leftmotor] = motorSpeedForward + motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward - motorSpeedTurn;
		}
	}
	else //Turning left
	{
		while(happy_angle > angle)
		{
			motor[leftmotor] = motorSpeedForward - motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward + motorSpeedTurn;
		}
	}
	motor[leftmotor]=0;
	motor[rightmotor]=0;
	printDebug();
	writeDebugStreamLine("End turnToAngle");

}

int turnUntilIRNot(int irValue, int motorSpeedTurn)
{
	while(readIR() >= irValue)
	{
		motor[leftmotor] = motorSpeedTurn;
		motor[rightmotor] = -motorSpeedTurn;
	}
	motor[leftmotor]=0;
	motor[rightmotor]=0;
	printDebug();

	return happy_angle;
}


void goStraightUntilIRNothing(int speed)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{

	servo[servo2]=127;
	int initValue = 0;
	int raw = 0;
	initValue = LSvalRaw(LightSensor);
	raw = initValue;
	while(readIR() > 0)//While loop saying that while the value of the light sensor is less than the value of the parametrically set stop value.
	{

		raw = LSvalRaw(LightSensor);
		nxtDisplayCenteredBigTextLine(1, "%d", raw);
		driveStraight (speed, 0);//Drivers forward with no light sensor value change (the null value is set in the parameters)
		printDebug();
	}
	writeDebugStreamLine("IR not found");
	motor[leftmotor]=0;
	motor[rightmotor]=0;
}

void goStraightUntilIRIS(int speed, int IRvalue, int angle)//Goes until the IR is a certain value defined parmetrically.
{
	while(readIR() != IRvalue)//While loop saying that while the value of the light sensor is less than the value of the parametrically set stop value.
	{
		driveStraight(speed, angle);//Drivers forward with no light sensor value change (the null value is set in the parameters)
		printDebug();
	}
	motor[leftmotor]=0;
	motor[rightmotor]=0;
}



int findLine()
{
	servo[servo2] = 0;
	int angle = 0;
	int initValue = 0;
	int initServo = 0;
	int delta = 1;
	int raw = 0;
	bool isFinished = false;
	int i = initServo;
	LSsetActive(LightSensor);
	servo[servo2] = i;
	wait10Msec(100);
	initValue = LSvalRaw(LightSensor);
	nxtDisplayBigTextLine(2, "%d", initValue);
	writeDebugStreamLine("  Initial Light:%d", initValue);
	raw = initValue;
	//for(i = initServo; abs(raw-initValue)<=60 && i < 255; i=i+delta)
	for(i = initServo; (raw<1320) && i < 255; i=i+delta)
	{
		raw = LSvalRaw(LightSensor);
		nxtDisplayBigTextLine(4, "%d", raw);
		if(abs(raw - initValue)> 4)
		{
			isFinished = true;
		}
		writeDebugStreamLine("  Angle:%3d, LS:%4d", i, LSvalRaw(LightSensor));
		wait10Msec(1);
		servo[servo2] = i;
	}
	angle = i * 180/255;
	int distance = 40*cosDegrees(angle);
	writeDebugStreamLine(" Angle:%3d, LS:%4d", i, LSvalRaw(LightSensor));
	writeDebugStreamLine("Line Found, Distance:%3d", distance);
	return distance;
};

int findLineRightColumn()
{
	servo[servo2] = 0;
	int angle = 0;
	int initValue = 0;
	int initServo = 255;
	int delta = 1;
	int raw = 0;
	bool isFinished = false;
	int i = initServo;
	LSsetActive(LightSensor);
	servo[servo2] = i;
	wait10Msec(100);
	initValue = LSvalRaw(LightSensor);
	nxtDisplayBigTextLine(2, "%d", initValue);
	writeDebugStreamLine("  Initial Light:%d", initValue);
	raw = initValue;
	//for(i = initServo; abs(raw-initValue)<=40 && i > 0; i=i-delta)
	for(i = initServo; (raw<1320) && i > 0; i=i-delta)
	{
		raw = LSvalRaw(LightSensor);
		nxtDisplayBigTextLine(4, "%d", raw);
		if(abs(raw - initValue)> 4)
		{
			isFinished = true;
		}
		writeDebugStreamLine("  Angle:%3d, LS:%4d", i, LSvalRaw(LightSensor));
		wait10Msec(1);
		servo[servo2] = i;
	}
	angle = i * 180/255;
	int distance = 40*cosDegrees(angle);
	writeDebugStreamLine(" Angle:%3d, LS:%4d", i, LSvalRaw(LightSensor));
	writeDebugStreamLine("Line Found, Distance:%3d", distance);
	return distance;
};


bool isCenter;
bool isLeft;

void alignWithColumnIR()
{
};

void alignWithColumn(int value)
{
	if(value == leftColumn)
	{
		isCenter = false;//Fix these
		isLeft = true;
	}
	else if(value == midColumn)
	{
		isCenter = true;
		isLeft = false;
	}
	else if(value == rightColumn)
	{
		isCenter = false;
		isLeft = false;
	}
	else
	{
		motor[rightmotor] = 0;
		motor[leftmotor] = 0;
		isCenter = true;
		isLeft = true;
	}

	//Is for following through with the previously found values.
	if(isCenter == true && isLeft == false)//Center
	{
		turnToAngle(40, 0, 0);
		//goStraightForTime(4000, 40);
		goStraightUntilIRNothing(60);
		turnToAngle(40, 0, 0);
		isLeft = true;
	}
	else if(isCenter == false && isLeft == true)//Left
	{
		turnToAngle(40, 0, -85);
		//goStraightForTime(2250, 40, -45);
		goStraightUntilIRIS(40, 8, -85);
		turnToAngle(40, 0, 0);
		goStraightUntilLightChanges(35);
		//goStraightUntilIRNothing(40);
		//goStraightForTime(500, 30, 0);
		turnToAngle(40, 0, 0);
		isLeft = true;
		isCenter = true;
	}
	else if(isCenter==false && isLeft == false)//Right
	{
		turnToAngle(40, 0, 95);
		//goStraightForTime(2250, 40, 45); This code was used for dead reckoning.
		goStraightUntilIRIS(35, 2, 95);
		turnToAngle(40, 0, 0);

		//goStraightUntilIRNothing(40);
		goStraightUntilLightChanges(35);
		//wait10Msec(100);
		//goStraightForTime(500, 30, 0);
		turnToAngle(40, 0, 0);
		isLeft = true;
		isCenter = true;

	}
	else
	{
		motor[rightmotor] = 0;
		motor[leftmotor] = 0;
	}

	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
	writeDebugStreamLine("At Column");
}


void determineColumn()
{
	int columnAngle = turnUntilIRNot(5, 40);
	nxtDisplayCenteredBigTextLine(4, "%d", columnAngle);
	wait10Msec(100);
	writeDebugStream("Column Found");
	if(columnAngle < 24)
	{
		alignWithColumn(leftColumn);
		columnNumber = leftColumn;
	}
	else if(columnAngle < 36)
	{
		alignWithColumn(midColumn);
		columnNumber = midColumn;
	}
	else
	{
		alignWithColumn(rightColumn);
		columnNumber = rightColumn;
	}
};
//1000ms on bucket is 65mm

task main()//Main task. Execution starts here.
{
	int distance;
	waitForStart();//Waiting for the start command from FCS, as sanctioned by the Game Manual
	clearDebugStream();
	LSsetActive(LightSensor);
	//raiseBucket();//Raise the bucket to the height of the first row of pegs on the scoring goal (for value, see the "raiseBucket" void function)

	//int IRState; //Gets value from the IR
	//StartTask (Play)
	servo[servo2]=0;
	servo[bucketservo] = 128;
	StartTask (update_gyroSensor);
	wait10Msec(150);
	//turnToAngle (20, 0, -90);
	//StopAllTasks ();

	goStraightForTime(1900, 64, 0);
	motor[leftmotor]=0;
	motor[rightmotor]=0;
	wait10Msec(100);
	determineColumn();
	goStraightUntilIRNothing(40);
	motor[leftmotor]=0;
	motor[rightmotor]=0;
	if(columnNumber == rightColumn)
	{
		distance = findLineRightColumn();
	}
	else
	{
		distance = findLine();
	}
	if(distance <= -39)
	{
		writeDebugStreamLine("Line not found. Moving servo and exiting.");
	}
	else if(distance == -8 || distance == -12)
	{
		writeDebugStreamLine("Line not found. Moving servo and exiting.");
	}
	else
	{
		raiseBucket();
		wait10Msec(100);
		moveBucket(distance);
		wait10Msec(100);
		nxtDisplayTextLine(1, "%d", distance);
		goStraightForTime(485, 30, 0);
		wait10Msec(100);
		lowerBucket();
		goBackwardForTime(500, -30, 0);
		wait10Msec(200);
	}

	//goStraightForTime(5000, 40, 0);
	//servo[servo2]=255;

}
