#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S4,     gyroSensor,     sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rightmotor,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftmotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     rightslidemotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftslidemotor, tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    bucketservo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
DANEIL, ADD THE ALLSTOP FUNCTION WITH FLAGS FOR FAILSAFE AND FOR GENERAL CONTROL
*/

#include <JoystickDriver.c>0
#include <hitechnic-sensormux.h>
#include <hitechnic-irseeker-v2.h>
#include <hitechnic-gyro.h>
#include <hitechnic-touchmux.h>
#include <lego-light.h>
//These are the drivers required for handling commands that are not present in a fresh install of RobotC.


const tMUXSensor LightSensor = msensor_S2_1;
const tMUXSensor irseeker = msensor_S2_2;
//These three lines declare the sensors that we are running through the sensor multiplexor.

const int leftColumn = 0;
const int midColumn = 1;
const int rightColumn = 2;
//Constant value declarations that are used to pass states between functions.

float happy_angle=0;

task update_gyroSensor()
{
	HTGYROstartCal(gyroSensor);
	while(true)
	{
		float angle=HTGYROreadRot(gyroSensor)/100.0;
		happy_angle=happy_angle+angle;
		nxtDisplayTextLine(7, "%d", happy_angle);
		wait1Msec (10);
	}
}

int readIR()
{
	int IRValue = HTIRS2readACDir(irseeker);
	return IRValue;
}//Returns the value of the IR sensor to be used by functions to have a sense of distance from the IR beacon.

void driveStraight (int motorSpeed, int angle)//Drives straight at an angle.
{
	motor[leftmotor] = motorSpeed;
	motor[rightmotor] = motorSpeed;
	//if (happy_angle < 3 && happy_angle > -3)//while straight go straight
	//{
	//	nxtDisplayTextLine(6, "Going Straight");
	//	motor[rightmotor]=motorSpeed;
	//	motor[leftmotor]=motorSpeed;
	//}
	if (happy_angle<0)// while rightmotor go leftmotor
	{
		nxtDisplayTextLine(6, "Going rightmotor");
		motor[rightmotor]=motorSpeed;
		motor[leftmotor]=motorSpeed;
	}
	else if (happy_angle>0)// while leftmotor go rightmotor
	{
		nxtDisplayTextLine(6, "Going leftmotor");

		motor[rightmotor]=motorSpeed * 2;
		motor[leftmotor]=motorSpeed * 0.15;
	}
}

void raiseBucket() //This function allows us to raise the linear slides in order to score.
{
	motor[leftslidemotor]=100;
	motor[rightslidemotor]=100;
	wait10Msec(75);
	motor[leftslidemotor]=0;
	motor[rightslidemotor]=0;
}

void lowerBucket()//Completing the opposite of the above raiseBucket() function.
{
	motor[leftslidemotor]=-100;
	motor[rightslidemotor]=-100;
	wait10Msec(75);
	motor[leftslidemotor]=0;
	motor[rightslidemotor]=0;
};

void goStraightForTime(int time, int speed)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{
	time1[T1] = 0;//Creating the aforementioned timer
	while (time1[T1] < time)//While loop saying that while the value of the timer is less than the value of the parametrically set stop time.
	{
		driveStraight (speed, 0);//Drivers forward with no angle change (the null value is set in the parameters)
	}
}

void goStraightUntilLightChanges(int speed)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{

	servo[servo2]=127;
	int initValue = 0;
	int raw = 0;
	initValue = LSvalRaw(LightSensor);
	raw = initValue;
	while(abs(raw-initValue)<=40)//While loop saying that while the value of the light sensor is less than the value of the parametrically set stop value.
	{
		raw = LSvalRaw(LightSensor);
		nxtDisplayCenteredBigTextLine(1, "%d", raw);
		driveStraight (speed, 0);//Drivers forward with no light sensor value change (the null value is set in the parameters)
	}
}

void turnToAngle(int motorSpeedTurn, int motorSpeedForward, int angle)//Takes the perimetrically set values and turns to an angle at the assigned motor speeds.
{
	bool turningRight = false;
	if(happy_angle < angle)
	{
		turningRight = true;
	}
	if(turningRight == true)
	{
		while(happy_angle < angle)
		{
			motor[leftmotor] = motorSpeedForward + motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward - motorSpeedTurn;
		}
	}
	else //Turning left
	{
		while(happy_angle > angle)
		{
			motor[leftmotor] = motorSpeedForward - motorSpeedTurn;
			motor[rightmotor] = motorSpeedForward + motorSpeedTurn;
		}
	}
}

int turnUntilIRNot(int irValue, int motorSpeedTurn)//Turns the robot in place until the IR reads a value that is not equivalent to the parametrically set condition value.
{
	while(readIR() == irValue)
	{
		motor[leftmotor] = motorSpeedTurn;
		motor[rightmotor] = -motorSpeedTurn;
	}
	motor[leftmotor]=0;
	motor[rightmotor]=0;

	return happy_angle;
}


void goStraightUntilIRNothing(int speed)//This function allows locomotion over a predefined period (per the parameters) and stop. We create a timer in order to measure the time elapsed between the beginning and end of execution of this function.
{

	servo[servo2]=127;
	int initValue = 0;
	int raw = 0;
	initValue = LSvalRaw(LightSensor);
	raw = initValue;
	while(readIR() > 0)//While loop saying that while the value of the light sensor is less than the value of the parametrically set stop value.
	{
		raw = LSvalRaw(LightSensor);
		nxtDisplayCenteredBigTextLine(1, "%d", raw);
		driveStraight (speed, 0);//Drivers forward with no light sensor value change (the null value is set in the parameters)
	}
}




int findLine()//Sweeps the servo-mounted light sensor to find a value that is 40 points from the absolute value of the initial reading.
{
	servo[servo2] = 0;
	int angle = 0;
	int initValue = 0;
	int raw = 0;
	bool isFinished = false;
	int i = 127;
	LSsetActive(LightSensor);
	wait10Msec(100);
	initValue = LSvalRaw(LightSensor);
	nxtDisplayBigTextLine(2, "%d", initValue);
	raw = initValue;
	for(i = 0; abs(raw-initValue)<=40 && i < 255; i++)
	{
		raw = LSvalRaw(LightSensor);
		nxtDisplayBigTextLine(4, "%d", raw);
		if(abs(raw - initValue)> 4)
		{
			isFinished = true;
		}
		wait10Msec(1);
		servo[servo2] = i;
	}
	angle = i * 180/255;
	int distance = 40*cosDegrees(angle);
	return distance;//The distance tells us how far we need to move the V-Bucket(Trademark Pending) in order to score autonomously.
};



bool isCenter;
bool isLeft;

/*void alignWithColumnIR()
{
};*/

void alignWithColumn(int value)//Receives a value from determineColumn() (see below) and moves the robot to be aligned with the Column of the IR beacon.
{
	if(value == leftColumn)
	{
		isCenter = false;
		isLeft = true;//If we know that the IR beacon is not on the center column, and that it is on the left column, we know that the IR beacon is on the left column.
	}
	else if(value == midColumn)
	{
		isCenter = true;
		isLeft = false;//If we know that the IR beacon is on the center column, and that it is not on the left column, we know that the IR beacon is on the center column.
	}
	}
	else if(value == rightColumn)
	{
		isCenter = false;
		isLeft = false;//If we know that the IR beacon is not on the center column, and that it is not on the left column, we know that the IR beacon is on the right column.
	}
	}
	else
	{
		motor[rightmotor] = 0;
		motor[leftmotor] = 0;
		isCenter = true;
		isLeft = true;//This is an illegal value. The IR beacon cannot be on the center and left column at the same time. That is impossible.
	}

	//Is for following through with the previously found values.
	if(isCenter == true && isLeft == false)//Center
	{
		turnToAngle(60, 0, 0);
		//goStraightForTime(4000, 40);
		goStraightUntilIRNothing(60);
		isLeft = true;
	}
	else if(isCenter == false && isLeft == true)//Left
	{
		turnToAngle(40, 0, -45);
		goStraightForTime(3000, 40);
		turnToAngle(40, 0, 0);
		isLeft = true;
		isCenter = true;
	}
	else if(isCenter==false && isLeft == false)//Right
	{
		turnToAngle(40, 0, 45);
		goStraightForTime(2250, 40);
		turnToAngle(40, 0, 0);
		isLeft = true;
		isCenter = true;

	}
	else
	{
		motor[rightmotor] = 0;
		motor[leftmotor] = 0;
	}
}

void determineColumn()
{
	int columnAngle = turnUntilIRNot(5, 50);
	nxtDisplayCenteredBigTextLine(4, "%d", columnAngle);
	wait10Msec(200);
	if(columnAngle < 24)
	{
		alignWithColumn(leftColumn);
	}
	else if(columnAngle < 36)
	{
		alignWithColumn(midColumn);
	}
	else
	{
		alignWithColumn(rightColumn);
	}
};
//1000ms on bucket is 65mm

task main()//Main task. Execution starts here.
{
	int distance;
	waitForStart();//Waiting for the start command from FCS, as sanctioned by the Game Manual
	LSsetActive(LightSensor);
	//raiseBucket();//Raise the bucket to the height of the first row of pegs on the scoring goal (for value, see the "raiseBucket" void function)

	//int IRState; //Gets value from the IR
	//StartTask (Play)
	servo[bucketservo] = 128;
	StartTask (update_gyroSensor);
	wait10Msec(350);

	//turnToAngle (20, 0, -90);
	//StopAllTasks ();

	goStraightForTime(1500, 64);
	motor[leftmotor]=0;
	motor[rightmotor]=0;
	wait10Msec(250);
	determineColumn();
	goStraightUntilLightChanges(40);
	goStraightForTime(200, 40);
	motor[leftmotor]=0;
	motor[rightmotor]=0;
	distance = findLine();
	nxtDisplayTextLine(1, "%d", distance);
	//lowerBucket();
	wait10Msec(200);
}
